<resources>
    <string name="app_name">KotlinApp</string>
    <string name="title_activity_login">Sign in app</string>

    <!-- Strings related to login -->
    <string name="prompt_email">Email</string>
    <string name="prompt_password">Password (optional)</string>
    <string name="action_sign_in">Sign in or register</string>
    <string name="action_sign_in_short">Sign in</string>
    <string name="error_invalid_email">This email address is invalid</string>
    <string name="error_invalid_password">This password is too short</string>
    <string name="error_incorrect_password">This password is incorrect</string>
    <string name="error_field_required">This field is required</string>
    <string name="permission_rationale">"Contacts permissions are needed for providing email
        completions."
    </string>
    <string name="string_pager_data">new data</string>
    <string name="app_desc"><![CDATA[Kotlin LEARN  COMMUNITY  TRY ONLINE Reference   Tutorials   Books   More resources Overview Kotlin for Server Side Kotlin for Android Kotlin for JavaScript Kotlin/Native What\'s New in 1.1 What\'s New in 1.2 Getting Started Basic Syntax Idioms Coding Conventions Basics Basic Types Packages and Imports Control Flow Returns and Jumps Classes and Objects Classes and Inheritance Properties and Fields Interfaces Visibility Modifiers Extensions Data Classes Sealed Classes Generics Nested Classes Enum Classes Objects Delegation Delegated Properties Functions and Lambdas Other Destructuring Declarations Collections Ranges Type Checks and Casts This expressions Equality Operator overloading Null Safety Exceptions Annotations Reflection Type-Safe Builders Type Aliases Multiplatform Projects Core Libraries Standard Library kotlin.test Reference Java Interop JavaScript Tools FAQ Full Kotlin Reference  Edit Page Delegated Properties There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:  lazy properties: the value gets computed only upon first access; observable properties: listeners get notified about changes to this property; storing properties in a map, instead of a separate field for each property. To cover these (and other) cases, Kotlin supports delegated properties:  class Example {     var p: String by Delegate() } The syntax is: val/var <property name>: <Type> by <expression>. The expression after by is the delegate, because get() (and set()) corresponding to the property will be delegated to its getValue() and setValue() methods. Property delegates don’t have to implement any interface, but they have to provide a getValue() function (and setValue() — for var\'s). For example:  class Delegate {     operator fun getValue(thisRef: Any?, property: KProperty<*>): String {         return \"$thisRef, thank you for delegating \'${property.name}\' to me!\"     }       operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {         println(\"$value has been assigned to \'${property.name} in $thisRef.\'\")     } } When we read from p that delegates to an instance of Delegate, the getValue() function from Delegate is called, so that its first parameter is the object we read p from and the second parameter holds a description of p itself (e.g. you can take its name). For example:  val e = Example() println(e.p) This prints:  Example@33a17727, thank you for delegating ‘p’ to me! Similarly, when we assign to p, the setValue() function is called. The first two parameters are the same, and the third holds the value being assigned:  e.p = \"NEW\" This prints  NEW has been assigned to ‘p’ in Example@33a17727. The specification of the requirements to the delegated object can be found below.  Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn\'t necessarily be a member of a class. Below you can find the example.  Standard Delegates The Kotlin standard library provides factory methods for several useful kinds of delegates.  Lazy lazy() is a function that takes a lambda and returns an instance of Lazy<T> which can serve as a delegate for implementing a lazy property: the first call to get() executes the lambda passed to lazy() and remembers the result, subsequent calls to get() simply return the remembered result.  val lazyValue: String by lazy {     println(\"computed!\")     \"Hello\" }  fun main(args: Array<String>) {     println(lazyValue)     println(lazyValue) } This example prints:  computed! Hello Hello By default, the evaluation of lazy properties is synchronized: the value is computed only in one thread, and all threads will see the same value. If the synchronization of initialization delegate is not required, so that multiple threads can execute it simultaneously, pass LazyThreadSafetyMode.PUBLICATION as a parameter to the lazy() function. And if you\'re sure that the initialization will always happen on a single thread, you can use LazyThreadSafetyMode.NONE mode, which doesn\'t incur any thread-safety guarantees and the related overhead.  Observable Delegates.observable() takes two arguments: the initial value and a handler for modifications. The handler gets called every time we assign to the property (after the assignment has been performed). It has three parameters: a property being assigned to, the old value and the new one:  import kotlin.properties.Delegates  class User {     var name: String by Delegates.observable(\"<no name>\") {         prop, old, new ->         println(\"$old -> $new\")     } }  fun main(args: Array<String>) {     val user = User()     user.name = \"first\"     user.name = \"second\" } This example prints:  <no name> -> first first -> second If you want to be able to intercept an assignment and \"veto\" it, use vetoable() instead of observable(). The handler passed to the vetoable is called before the assignment of a new property value has been performed.  Storing Properties in a Map One common use case is storing the values of properties in a map. This comes up often in applications like parsing JSON or doing other “dynamic” things. In this case, you can use the map instance itself as the delegate for a delegated property.  class User(val map: Map<String, Any?>) {     val name: String by map     val age: Int     by map } In this example, the constructor takes a map:  val user = User(mapOf(     \"name\" to \"John Doe\",     \"age\"  to 25 )) Delegated properties take values from this map (by the string keys –– names of properties):  println(user.name) // Prints \"John Doe\" println(user.age)  // Prints 25 This works also for var’s properties if you use a MutableMap instead of read-only Map:  class MutableUser(val map: MutableMap<String, Any?>) {     var name: String by map     var age: Int     by map } Local Delegated Properties (since 1.1) You can declare local variables as delegated properties. For instance, you can make a local variable lazy:  fun example(computeFoo: () -> Foo) {     val memoizedFoo by lazy(computeFoo)      if (someCondition && memoizedFoo.isValid()) {         memoizedFoo.doSomething()     } } The memoizedFoo variable will be computed on the first access only. If someCondition fails, the variable won\'t be computed at all.  Property Delegate Requirements Here we summarize requirements to delegate objects.  For a read-only property (i.e. a val), a delegate has to provide a function named getValue that takes the following parameters:  thisRef — must be the same or a supertype of the property owner (for extension properties — the type being extended); property — must be of type KProperty<*> or its supertype. this function must return the same type as property (or its subtype).  For a mutable property (a var), a delegate has to additionally provide a function named setValue that takes the following parameters:  thisRef — same as for getValue(); property — same as for getValue(); new value — must be of the same type as a property or its supertype. getValue() and/or setValue() functions may be provided either as member functions of the delegate class or extension functions. The latter is handy when you need to delegate property to an object which doesn\'t originally provide these functions. Both of the functions need to be marked with the operator keyword.  The delegate class may implement one of the interfaces ReadOnlyProperty and ReadWriteProperty containing the required operator methods. These interfaces are declared in the Kotlin standard library:  interface ReadOnlyProperty<in R, out T> {     operator fun getValue(thisRef: R, property: KProperty<*>): T }  interface ReadWriteProperty<in R, T> {     operator fun getValue(thisRef: R, property: KProperty<*>): T     operator fun setValue(thisRef: R, property: KProperty<*>, value: T) } Translation Rules Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property prop the hidden property prop$delegate is generated, and the code of the accessors simply delegates to this additional property:  class C {     var prop: Type by MyDelegate() }  // this code is generated by the compiler instead: class C {     private val prop$delegate = MyDelegate()     var prop: Type         get() = prop$delegate.getValue(this, this::prop)         set(value: Type) = prop$delegate.setValue(this, this::prop, value) } The Kotlin compiler provides all the necessary information about prop in the arguments: the first argument this refers to an instance of the outer class C and this::prop is a reflection object of the KProperty type describing prop itself.  Note that the syntax this::prop to refer a bound callable reference in the code directly is available only since Kotlin 1.1.  Providing a delegate (since 1.1) By defining the provideDelegate operator you can extend the logic of creating the object to which the property implementation is delegated. If the object used on the right hand side of by defines provideDelegate as a member or extension function, that function will be called to create the property delegate instance.  One of the possible use cases of provideDelegate is to check property consistency when the property is created, not only in its getter or setter.  For example, if you want to check the property name before binding, you can write something like this:  class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {     override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... } }      class ResourceLoader<T>(id: ResourceID<T>) {     operator fun provideDelegate(             thisRef: MyUI,             prop: KProperty<*>     ): ReadOnlyProperty<MyUI, T> {         checkProperty(thisRef, prop.name)         // create delegate         return ResourceDelegate()     }      private fun checkProperty(thisRef: MyUI, name: String) { ... } }  class MyUI {     fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }      val image by bindResource(ResourceID.image_id)     val text by bindResource(ResourceID.text_id) } The parameters of provideDelegate are the same as for getValue:  thisRef — must be the same or a supertype of the property owner (for extension properties — the type being extended); property — must be of type KProperty<*> or its supertype. The provideDelegate method is called for each property during the creation of the MyUI instance, and it performs the necessary validation right away.  Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you\'d have to pass the property name explicitly, which isn\'t very convenient:  // Checking the property name without \"provideDelegate\" functionality class MyUI {     val image by bindResource(ResourceID.image_id, \"image\")     val text by bindResource(ResourceID.text_id, \"text\") }  fun <T> MyUI.bindResource(         id: ResourceID<T>,         propertyName: String ): ReadOnlyProperty<MyUI, T> {    checkProperty(this, propertyName)    // create delegate } In the generated code, the provideDelegate method is called to initialize the auxiliary prop$delegate property. Compare the generated code for the property declaration val prop: Type by MyDelegate() with the generated code above (when the provideDelegate method is not present):  class C {     var prop: Type by MyDelegate() }  // this code is generated by the compiler  // when the \'provideDelegate\' function is available: class C {     // calling \"provideDelegate\" to create the additional \"delegate\" property     private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)     val prop: Type         get() = prop$delegate.getValue(this, this::prop) } Note that the provideDelegate method affects only the creation of the auxiliary property and doesn\'t affect the code generated for getter or setter.  Licensed under the Apache 2 license Sponsored and developed by JetBrains esc]]></string>
    <string name="title_activity_scrolling">ScrollingActivity</string>
    <string name="large_text">
        "Material is the metaphor.\n\n"

        "A material metaphor is the unifying theory of a rationalized space and a system of motion."
        "The material is grounded in tactile reality, inspired by the study of paper and ink, yet "
        "technologically advanced and open to imagination and magic.\n"
        "Surfaces and edges of the material provide visual cues that are grounded in reality. The "
        "use of familiar tactile attributes helps users quickly understand affordances. Yet the "
        "flexibility of the material creates new affordances that supercede those in the physical "
        "world, without breaking the rules of physics.\n"
        "The fundamentals of light, surface, and movement are key to conveying how objects move, "
        "interact, and exist in space and in relation to each other. Realistic lighting shows "
        "seams, divides space, and indicates moving parts.\n\n"

        "Bold, graphic, intentional.\n\n"

        "The foundational elements of print based design typography, grids, space, scale, color, "
        "and use of imagery guide visual treatments. These elements do far more than please the "
        "eye. They create hierarchy, meaning, and focus. Deliberate color choices, edge to edge "
        "imagery, large scale typography, and intentional white space create a bold and graphic "
        "interface that immerse the user in the experience.\n"
        "An emphasis on user actions makes core functionality immediately apparent and provides "
        "waypoints for the user.\n\n"

        "Motion provides meaning.\n\n"

        "Motion respects and reinforces the user as the prime mover. Primary user actions are "
        "inflection points that initiate motion, transforming the whole design.\n"
        "All action takes place in a single environment. Objects are presented to the user without "
        "breaking the continuity of experience even as they transform and reorganize.\n"
        "Motion is meaningful and appropriate, serving to focus attention and maintain continuity. "
        "Feedback is subtle yet clear. Transitions are efﬁcient yet coherent.\n\n"

        "3D world.\n\n"

        "The material environment is a 3D space, which means all objects have x, y, and z "
        "dimensions. The z-axis is perpendicularly aligned to the plane of the display, with the "
        "positive z-axis extending towards the viewer. Every sheet of material occupies a single "
        "position along the z-axis and has a standard 1dp thickness.\n"
        "On the web, the z-axis is used for layering and not for perspective. The 3D world is "
        "emulated by manipulating the y-axis.\n\n"

        "Light and shadow.\n\n"

        "Within the material environment, virtual lights illuminate the scene. Key lights create "
        "directional shadows, while ambient light creates soft shadows from all angles.\n"
        "Shadows in the material environment are cast by these two light sources. In Android "
        "development, shadows occur when light sources are blocked by sheets of material at "
        "various positions along the z-axis. On the web, shadows are depicted by manipulating the "
        "y-axis only. The following example shows the card with a height of 6dp.\n\n"

        "Resting elevation.\n\n"

        "All material objects, regardless of size, have a resting elevation, or default elevation "
        "that does not change. If an object changes elevation, it should return to its resting "
        "elevation as soon as possible.\n\n"

        "Component elevations.\n\n"

        "The resting elevation for a component type is consistent across apps (e.g., FAB elevation "
        "does not vary from 6dp in one app to 16dp in another app).\n"
        "Components may have different resting elevations across platforms, depending on the depth "
        "of the environment (e.g., TV has a greater depth than mobile or desktop).\n\n"

        "Responsive elevation and dynamic elevation offsets.\n\n"

        "Some component types have responsive elevation, meaning they change elevation in response "
        "to user input (e.g., normal, focused, and pressed) or system events. These elevation "
        "changes are consistently implemented using dynamic elevation offsets.\n"
        "Dynamic elevation offsets are the goal elevation that a component moves towards, relative "
        "to the component’s resting state. They ensure that elevation changes are consistent "
        "across actions and component types. For example, all components that lift on press have "
        "the same elevation change relative to their resting elevation.\n"
        "Once the input event is completed or cancelled, the component will return to its resting "
        "elevation.\n\n"

        "Avoiding elevation interference.\n\n"

        "Components with responsive elevations may encounter other components as they move between "
        "their resting elevations and dynamic elevation offsets. Because material cannot pass "
        "through other material, components avoid interfering with one another any number of ways, "
        "whether on a per component basis or using the entire app layout.\n"
        "On a component level, components can move or be removed before they cause interference. "
        "For example, a floating action button (FAB) can disappear or move off screen before a "
        "user picks up a card, or it can move if a snackbar appears.\n"
        "On the layout level, design your app layout to minimize opportunities for interference. "
        "For example, position the FAB to one side of stream of a cards so the FAB won’t interfere "
        "when a user tries to pick up one of cards.\n\n"
    </string>
    <string name="action_settings">Settings</string>
</resources>
